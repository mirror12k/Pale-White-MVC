package PaleWhite::GlassParser


identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+/
symbol_regex = /!|\.|\#|=|,/

indent_regex = /\t++/
whitespace_regex = /[\t \r]++/
newline_regex = /\s*\n/s
string_regex = /"([^\\"]|\\[\\"])*?"/s

escape_string_substitution = s/\\([\\"])/$1/gs
format_string_substitution = s/\A"(.*)"\Z/$1/s



tokens {
	identifier => $identifier_regex
	symbol => $symbol_regex
	string => $string_regex

	indent => $indent_regex
	whitespace => $whitespace_regex
	newline => $newline_regex
}

ignored_tokens {
	whitespace
}



object context root {
	$_ = !root_glass_block->{
		type => 'root'
		block => []
		indent => ''
	}
	return
}


object context root_glass_block {
	while $newline_regex => {
		# skip newline
	}

	if &match_indent->$_ => {
		$_{block}[] = !glass_block->!glass_item->$0
	} else {
		$_{block}[] = !glass_block->!glass_item->''
	}
}


object context glass_block {
	while $newline_regex => {
		# skip newline
	}
	switch {
		&match_indent->$_ => {
			$_{block}[] = !glass_block->!glass_item->$0
		}
		default {
			return
		}
	}
}

object context glass_item {
	# we cheat by passing in the indent as the argument
	switch {
		'!', $identifier_regex => {
			$_ = !glass_helper->{
				type => 'glass_helper'
				line_number => $0{line_number}
				identifier => $1
				indent => $_
			}
			match $newline_regex
			return
		}
		$identifier_regex => {
			$_ = !glass_tag_text->!parse_attribute_arguments->!glass_tag->{
				type => 'html_tag'
				line_number => $0{line_number}
				identifier => $0
				indent => $_
			}
			match $newline_regex
			return
		}
		default {
			die 'glass item expected'
		}
	}
}


object context glass_tag {
	switch {
		'.', $identifier_regex => {
			$_{class}[] = $1
		}
		'#', $identifier_regex => {
			$_{id} = $1
		}
		default {
			return
		}
	}
}

object context parse_attribute_arguments {
	if $identifier_regex => {
		match '='
		$_{attributes}{$0} = !glass_expression

		while ',' => {
			match $identifier_regex, '='
			$_{attributes}{$3} = !glass_expression
		}
	}
	return
}

object context glass_tag_text {
	if $string_regex => {
		$_{text} = !format_string->$0
	}
	return
}

object context glass_expression {
	switch {
		$string_regex => {
			$_ = !format_string->$0
			return
		}
		default {
			die 'expression expected'
		}
	}
}


object context glass_helper {
	match $identifier_regex
	$_{identifier_argument} = $0
	$_ = !parse_attribute_arguments->$_

	return
}


item context format_string {
	$_ = $escape_string_substitution->
			$format_string_substitution->$_
	return
}






sub match_indent {{
	my ($self, $offset, $item) = @_;
	return ($self->{tokens}[$offset][1] =~ /\A\t++\Z/
		and length $self->{tokens}[$offset][1] > length $item->{indent})
}}

sub main {{
	use Data::Dumper;
	use Sugar::IO::File;

	my $parser = __PACKAGE__->new;
	foreach my $file (@_) {
		$parser->{filepath} = Sugar::IO::File->new($file);
		my $tree = $parser->parse;
		say Dumper $tree;
	}
}}


